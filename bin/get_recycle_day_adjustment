#!/usr/bin/env bash

for f in curl jq; do
  ! command -v $f &> /dev/null && echo "Error: The '$f' command is required" > /dev/stderr && exit 1
done

supported_engines=(chatgpt claude gemini github localai mistral ollama openrouter)
engine_settings=(enabled url api_key model prompt match max_tokens extra thinking_level agent_id)
declare -A ${supported_engines[@]}
debug="${debug:-false}"
extra_debug="${extra_debug:-false}"
debug_exit=false
verbose="${verbose:-false}"
extra_verbose="${extra_verbose:-false}"
output_json="${output_json:-false}"
today_date="$(date "+%Y-%m-%d")"
run_all="${run_all:-false}"

engine_order="${engine_order:-localai ollama mistral openrouter gemini claude chatgpt}"

declare -A url model match max_tokens thinking_level extra

chatgpt[url]="${chatgpt_url:-https://api.openai.com/v1/responses}"
chatgpt[model]="${chatgpt_model:-gpt-5-mini}"
chatgpt[match]="${chatgpt_match:-.output[0].content[0].text}"

claude[url]="${claude_url:-https://api.anthropic.com/v1/messages}"
claude[model]="${claude_model:-claude-sonnet-4-20250514}"
claude[max_tokens]="${claude_max_tokens:-100}"
claude[match]="${claude_match:-.content[0].text}"
claude[extra]="anthropic_version=${anthropic_version:-2023-06-01}|another_setting=a=1234%%PIPE%%5678|foobar=baz"

gemini[url]="${gemini_url:-https://generativelanguage.googleapis.com/v1beta/models/%%MODEL%%:generateContent}"
gemini[model]="${gemini_model:-gemini-3-flash-preview}"
gemini[thinking_level]="${gemini_thinking_level:-low}"
gemini[match]="${gemini_match:-.candidates[0].content.parts[0].text}"

github[url]="${github_url:-https://models.github.ai/inference/chat/completions}"
github[model]="${github_model:-microsoft/Phi-4-mini-reasoning}"
github[match]="${github_match:-.choices[0].message.content}"

mistral[url]="${mistral_url:-https://api.mistral.ai/v1/conversations}"
mistral[model]="${mistral_model:-mistral-medium-latest}"
mistral[match]="${mistral_match:-.outputs[0].content}"

openrouter[url]="${openrouter_url:-https://openrouter.ai/api/v1/chat/completions}"
openrouter[model]="${openrouter_model:-openai/gpt-5.2}"
openrouter[match]="${openrouter_match:-.output[0].content[0].text}"

secrets_file="${secrets_file:-$(readlink -f $(dirname "$0")/../secrets.yaml)}"

unset answer_json responses_json
agreements=0
run_count=0

setvar() {
  local var=$1
  var=${var# }  # Trim space
  var=${var% }  # Trim space
  var=${var#\"}  # Trim quote
  var=${var%\"}  # Trim quote
  var=${var#\'}  # Trim quote
  var=${var%\'}  # Trim quote
  echo "$var"
}
# Validate secrets file

[ ! -r "$secrets_file" ] && echo "Error: Cannot open secrets file" && exit 1
! grep -q "^recycle_day_" "$secrets_file" && echo "Error: No recycle_day secrets in secrets file" && exit 1

# Get common settings
for var in home_assistant_base_url recycle_url_main recycle_default_day ; do
  [[ ! "${!var}" ]] && declare "$var=$(setvar "$(awk "/^$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")")"
  [[ $var == home_assistant_base_url ]] && [[ ! $home_assistant_base_url ]] && home_assistant_base_url=http://localhost:8123
  [[ $var == recycle_url_main ]] && [[ ! $recycle_url_main ]] && recycle_url_main=https://www.montgomerycountymd.gov/DEP/trash-recycling/index.html
  [[ $var == recycle_default_day ]] && [[ ! $recycle_default_day ]] && recycle_default_day=Friday
done

# Get general program settings that do not overwrite previous values
for var in hass_api_key min_agree ; do
  [[ ! "${!var}" ]] && declare "$var=$(setvar "$(awk "/^recycle_day_$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")")"
done
min_agree=${min_agree:-2}
declare -A days
day_list=(Sunday Monday Tuesday Wednesday Thursday Friday Saturday)
for i in "${!day_list[@]}"; do days["${day_list[$i]}"]=$i; done

for var in engine_order ; do
  tmpval=$(awk "/^recycle_day_$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")
  [[ $tmpval ]] && declare "$var=$(setvar "$tmpval")"
  unset tmpval
done

# Get program settings that do overwrite previous values
for engine in ${supported_engines[@]}; do
  for setting in ${engine_settings[@]}; do
    tmpval=$(awk "/^recycle_day_${engine}_$setting ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")
    [[ $tmpval ]] && declare "$engine[$setting]=$(setvar "$tmpval")"
    unset tmpval
  done
done

# How to define extras
for engine in ${supported_engines[@]}; do
  declare -n ref=$engine
  oifs=$IFS
  IFS='|'
  for word in ${ref[extra]}; do
    [[ ! $word =~ ^[A-Za-z0-9_]+=. ]] && echo "Error: $word is not a valid extra setting" && exit 1
    key=${word%%=*}
    value=${word#*=}
    value=${value//%%PIPE%%/|}
    ref[$key]=$value
  done
  IFS=$oifs
  unset -n ref
done

model_count=0
for engine in $engine_order; do
  declare -n ref=$engine
  for model in ${ref[model]//|/ }; do
    ((model_count++))
  done
done

usage() {
  echo "usage: $(basename $0) [-h] [-D] [-d] [-v] [-j] [-t TESTDATE] [-a ANSWER] [-A] [-m MIN_AGREE]"
  echo "                      [ENGINELIST] [MODELLIST]"
  echo "  -d           : Print debug information (second -d is extra debug information)"
  echo "  -d           : Print debug information and exit"
  echo "  -v           : Be verbose (second -v is extra verbose)"
  echo "  -j           : Output using JSON"
  echo "  -J           : Output simple response (i.e. 'Friday')"
  echo "  -A           : Run all configured engines/models, even after agreement requirements met"
  echo "  -t TESTDATE  : Use a test date instead of today (must be YYYY-mm-dd)"
  echo "  -a ANSWER    : Hardcode an answer"
  echo "  -m MIN_AGREE : Minimum number of LLMs must agree on answer (default: $min_agree)"
  echo
  echo "  ENGINELIST can one or more of: ${supported_engines[@]}"
  echo "  If specified, MODELLIST must be: A list of models that would have to match the ENGINE list"
  echo "  The first engine given would be matched with the first model given"
  echo "  ENGINELIST and MODELLIST are space separated on the command line"
  echo "  If MODELLIST is empty and ENGINELIST is set, models will be used from $secrets_file"
  echo "  ENGINES must precede MODELS on command line"
  echo "  Examples:"
  echo "    $(basename $0) -j ollama gemma3:4b localai gemma-3-4b-it"
  echo "    $(basename $0) -j ollama localai gemma3:4b gemma-3-4b-it"
  echo "    $(basename $0) -j gemma3:4b gemma-3-4b-it ollama localai"
  exit $1
}

min_agree_set=false
while getopts ":hdDvJjt:a:Am:" opt; do
  case $opt in
    d)
       $debug && extra_debug=true
       debug=true ;;
    D)
       debug=true
       debug_exit=true ;;
    v)
       $verbose && extra_verbose=true
       verbose=true
       ;;
    j) output_json=true ;;
    J) output_json=false ;;
    a) answer=$OPTARG ;;
    t)
       if [[ $OPTARG =~ ^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$ ]]; then
         today_date=$(date -d "$OPTARG" "+%Y-%m-%d")
         [ $? != 0 ] && echo "Error: Could not use date '$OPTARG'" && exit 1
       else
         echo "Error: Invalid date format ($OPTARG)"
         exit 1
       fi
       ;;
    A) run_all=true ;;
    m)
       [[ ! $OPTARG =~ ^[0-9]+$ ]] && echo "Error: MIN_AGREE must be a number" && exit 1
       min_agree_set=true
       min_agree=$OPTARG ;;
    *) usage ;;
  esac
done
shift $((OPTIND -1))
[ $run_all != true ] && run_all=false

add_to_json_array() {
  # usage: add_to_json_array json_array_string new_json_element
  [ -z "$2" ] && return 1
  echo "${1:-"[]"}" | jq -c --argjson e "$2" '. + [ $e ]'
}

# Set up fake answer information
if [[ $answer ]]; then
  min_agree=2
  model_count=2
  engine_order="manual"
  if ((${days[$answer]} < ${days[$recycle_default_day]})); then
    num_days=$((7+${days[$answer]}-${days[$recycle_default_day]}))
  else
    num_days=$((${days[$answer]}-${days[$recycle_default_day]}))
  fi
  [ $num_days != 0 ] && is_affected=true

  answer_json=$(echo "{\"day\":\"$answer\",\"is_affected\":${aff:-false},\"num_days\":$num_days,\"agreements\":2,\"min_agree\":$min_agree,\"run_count\":2,\"error\":false}" | jq -c)
  responses_json=$(add_to_json_array "$responses_json" '  {
    "engine": "manual",
    "model": "answer1",
    "process_seconds": 0,
    "day": "'$answer'",
    "is_affected": '${aff:-false}',
    "num_days": '$num_days'
  }')
  responses_json=$(add_to_json_array "$responses_json" '  {
    "engine": "manual",
    "model": "answer2",
    "process_seconds": 0,
    "day": "'$answer'",
    "is_affected": '${aff:-false}',
    "num_days": '$num_days'
  }')
  unset days aff
fi

# Get min_agree ratio as a baseline
if ! $min_agree_set; then
  # Get original model count
  min_agree_orig=$min_agree
  model_count_orig=0
  for engine in $engine_order; do
    mycount=0
    declare -n ref=$engine
    if [ -n "${ref[model]}" ]; then
      oifs=$IFS
      IFS='|'
      for word in ${ref[model]}; do
        ((mycount++))
      done
      IFS=$oifs
    fi
    [ $mycount -eq 0 ] && mycount=1
    unset -n ref
    model_count_orig=$((model_count_orig + mycount))
  done
  ratio=$((min_agree * 100 / $model_count_orig))
fi

# Parse command line for engines and models
engines=()
models=()
engines_list="${supported_engines[@]}"
engines_list="${engines_list// /|}"
adjust_min_agree=false
while [ -n "$1" ]; do
  if [[ $1 =~ ^($engines_list)$ ]]; then
    engines+=($1)
  else
    [ ${#engines[@]} -eq 0 ] && echo "Error: engines must precede models on command line" > /dev/stderr && exit 1
    models[$((${#engines[@]}-1))]=$1
  fi
  shift
done
if [ ${#engines[@]} -gt 0 ]; then
  adjust_min_agree=true
  for engine in ${supported_engines[@]}; do
    declare -n ref=$engine
    ref[enabled]=false
    unset -n ref
  done
  for engine in "${engines[@]}"; do
    declare -n ref=$engine
    ref[enabled]=true
    unset -n ref
  done
  engine_order="${engines[@]}"
fi
if [ ${#engines[@]} -gt 1 ]; then
  if [ ${#models[@]} -gt 0 ]; then
     for i in $(seq 0 $((${#engines[@]} - 1))); do
       if [ -n "${models[$i]}" ]; then
         declare -n ref=${engines[i]}
         ref[model]="${models[$i]}"
         unset -n ref
       fi
     done
  fi
elif [ ${#engines[@]} -eq 1 ]; then
  if [ ${#models[@]} -eq 1 ]; then
    adjust_min_agree=false
    min_agree=1
    model_count=1
    declare -n ref=${engines[0]}
    ref[model]="${models[0]}"
    # [[ ! ${ref[model]} =~ "|" ]] && min_agree=1
    unset -n ref
  else
    if [ ${#models[@]} -ne 0 ]; then
      echo "Error: Engine/Model mismatch. The same number of engines and models must be passed." > /dev/stderr
      echo > /dev/stderr
      usage 1
    fi
  fi
fi

# Adjust min_agree
if $adjust_min_agree && ! $min_agree_set; then
  model_count=0
  for engine in $engine_order; do
    declare -n ref=$engine
    if [ -n "${ref[model]}" ]; then
      mycount=0
      oifs=$IFS
      IFS='|'
      for word in ${ref[model]}; do
        ((mycount++))
      done
      IFS=$oifs
    fi
    [ $mycount -eq 0 ] && mycount=1
    unset -n ref
    model_count=$((model_count + mycount))
  done
  min_agree=$((model_count * ratio / 100))
  [ $ratio != 100 ] && [ $model_count = $min_agree ] && min_agree=$((min_agree-1))
  [ $min_agree = 1 ] && [ $min_agree_orig -gt 1 ] && [ $model_count -gt 1 ] && min_agree=2
fi

# Get whether Home Assistant toggle for using AI is enabled
[[ ! $hass_api_key ]] && echo "Error: Cannot determine hass_api_key from $secrets_file" && exit 1
use_ai=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_boolean.use_ai_for_recycle_day | jq -r .state)
if [ "${use_ai,,}" != "on" ]; then
  $debug && echo "Warning: Use AI for Recycle Day is not 'on' in Home Assistant" > /dev/stderr
  exit
fi

# Get normal recycle day from Home Assistant
normal_recycle_day=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_select.recycle_day | jq -r .state)
[[ ! $normal_recycle_day ]] && normal_recycle_day=$recycle_default_day
$verbose && echo "Normal recycle day: $normal_recycle_day" > /dev/stderr

# Set reference day to the normal recycle day for this week (or of the passed week)
epoch=$(date ${today_date:+-d $today_date} +%s)
dow=$(date ${today_date:+-d $today_date} +%w)
reference_date=$(date -d "@$(( epoch + (5 - dow) * 86400 ))" +"%A, %B %-d")
reference_ymd=$(date -d "@$(( epoch + (5 - dow) * 86400 ))" +"%Y-%m-%d")
$verbose && echo "Reference date: $reference_date ($reference_ymd)" > /dev/stderr

# Determine the URL for the county's alert text on the recycle URL
xmllint=false
command -v xmllint &> /dev/null && xmllint=true
if $xmllint; then
  county_alert_url=$(curl -sL $recycle_url_main | \
    xmllint --html --xpath 'string(//div[@id="alert"]/following-sibling::script)' - 2>/dev/null | \
    sed -n 's/.*load("\([^"]*\)".*/\1/p')
else
  county_alert_url=$(curl -sL $recycle_url_main | \
    sed -n 's/.*$("#alert").load("\([^"]*\)".*/\1/p')
fi
$verbose && echo "County Alert URL: $county_alert_url" > /dev/stderr

# Determine the content of the county's alert text
if $xmllint && [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL $county_alert_url | xmllint --html --xpath 'string(//body)' - 2> /dev/null | \
    sed -r 's/^\s*//;/^\s*$/d' | paste -sd " ")
elif [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL "$county_alert_url" | \
    sed -r ':a;N;$!ba;s/\n/ /g;s/(&nbsp;|\r)/ /g;s/<!--.*-->//g;s/ +/ /g;s/<[^>]*>//g;s/^ +//')
else
  echo "Warning: Invalid MoCo Alert/Warning URL ($county_alert_url)" > /dev/stderr
fi
if $extra_verbose; then
  echo "County Notice:" > /dev/stderr
  echo "    $county_alert_text" | fold -sw $((COLUMNS - 4)) | sed "2,\$s/^/$(printf '%*s' 4)/" > /dev/stderr
elif $verbose; then
  width=$((COLUMNS - 4))  # Number of columns - width of "County Notice: " - padding
  unset dots
  county_notice="$(echo "County Notice: \"$(echo "$county_alert_text" | paste -sd ' ')" | fold -sw $width | head -n1)"
  [ ${#county_alert_text} -gt $width ] && dots=…
  printf "%s%s\"\n" "$county_notice" "$dots" > /dev/stderr
fi

# Set the user message to send to the LLM
# user_message=${user_message:-My normal recycling pickup weekday is $normal_recycle_day and today is $reference_date. $county_alert_text If nothing so far has indicated that the recycling will change this week, then the day the county will pick up my recycle should be the normal recycling pickup weekday. Briefly tell me which weekday will the county come to pick up my recycle this week?}

#user_message="${user_message:-County website notice:
#\"${county_alert_text/// }\"
#
#For the date $reference_date, will my recycling pickup day change due to the county website notice? If yes, by how many days will it be delayed?
#
#Return your answer in the following format (do not add any extra text or explanation):
#{
#  \"date\": \"[INSERT_DATE]\",
#  \"is_affected\": [true/false],
#  \"delay_days\": [number of days delayed, or 0 if not affected]
#}}"
user_message="${user_message:-County website notice:
\"${county_alert_text/// }\"

Consider whether a recycling pickup on $reference_date is during the same week as any holiday mentioned in the notice, if it is on or after the holiday during that week, and if my recycling pickup day will change due to the county website notice. If yes, by how many days will it be delayed?

Return your answer in the following format (do not add any extra text or explanation):
{
  \"date\": \"[INSERT_DATE]\",
  \"is_affected\": [true/false],
  \"delay_days\": [number of days delayed, or 0 if not affected]
}}"

if $extra_verbose; then
  echo "LLM User Message:" > /dev/stderr
  echo "    $user_message" | fold -sw $((COLUMNS - 4)) | sed "2,\$s/^/$(printf '%*s' 4)/" > /dev/stderr
elif $verbose; then
  width=$((COLUMNS - 4))  # Number of columns - width of "County Notice: " - padding
  unset dots
  usermsg_text="$(echo "LLM User Message: \"$(echo "$user_message" | paste -sd ' ')" | fold -sw $width | head -n1)"
  [ ${#user_message} -gt $width ] && dots=…
  printf "%s%s\"\n" "$usermsg_text" "$dots" > /dev/stderr
fi

# The grep string used to find a day of the week
day_search='\b([Ss]un|[Mm]on|[Tt]ues|[Ww]ednes|[Tt]hurs|[Ff]ri|[Ss]atur)day\b'

# If debug mode, print variables
if $debug; then
  echo "Settings: " > /dev/stderr
  for var in secrets_file home_assistant_base_url hass_api_key recycle_url_main county_alert_url recycle_default_day normal_recycle_day today_date reference_date reference_ymd min_agree user_message engine_order ; do
    [ $var = user_message ] && printf ' - %s = "%s"\n' "$var" "$(echo "${!var}" | fold -sw $((COLUMNS - ${#var} - 3))|sed "2,\$s/^/$(printf '%*s' $((${#var} - 3)))/")" > /dev/stderr
    ! [ $var = user_message ] && printf ' - %s = "%s"\n' "$var" "${!var}" > /dev/stderr
  done
  list=$engine_order
  $extra_debug && list=${supported_engines[@]}
  for engine in $list; do
    for setting in ${engine_settings[@]}; do
      declare -n ref=$engine
      printf ' - %s = "%s"\n' "$engine[$setting]" "${ref[$setting]}" > /dev/stderr
      unset -n ref
    done
  done
  $debug_exit && exit
fi

# Function to check if the minimum number of LLMs agree on their answer
check_agreement() {
  local count
  local max=0
  local answer=""
  declare -A count
  local day_count aff_count num_count
  declare -A day_count aff_count num_count

  $debug && echo "responses_json = '$responses_json'" > /dev/stderr
  eval_string=$(echo "$responses_json" | \
    jq -r '.[] | "((day_count[\"\(.day)\"]++));
                  ((aff_count[\"\(.is_affected)\"]++));
                  ((num_count[\"\(.num_days)\"]++));"'
  )

  if [[ $eval_string =~ ^(\(\(day_count\[\"[^\"]+\"\]\+\+\)\)\;[[:space:]]*\(\(aff_count\[\"[^\"]+\"\]\+\+\)\)\;[[:space:]]*\(\(num_count\[\"[^\"]+\"\]\+\+\)\)\;?[[:space:]]*){1,}$ ]]; then
    eval "$eval_string"
  else
    echo "Bad Agreement Eval String ($eval_string)" > /dev/stderr
    exit 1
  fi

  local day_max=0 aff_max=0 num_max=0
  for v in "${!day_count[@]}"; do (( day_count[$v] > day_max )) && day_max=${day_count[$v]} && day_answer=$v; done
  for v in "${!aff_count[@]}"; do (( aff_count[$v] > aff_max )) && aff_max=${aff_count[$v]} && aff_answer=$v; done
  for v in "${!num_count[@]}"; do (( num_count[$v] > num_max )) && num_max=${num_count[$v]} && num_answer=$v; done

  $debug && echo "Day Agreements found: $day_max" > /dev/stderr
  $debug && echo "Aff Agreements found: $aff_max" > /dev/stderr
  $debug && echo "Num Agreements found: $num_max" > /dev/stderr
  $debug && (( $day_max < $min_agree )) && echo "Not enough agreements for Day" > /dev/stderr
  $debug && (( $aff_max < $min_agree )) && echo "Not enough agreements for Affected" > /dev/stderr
  $debug && (( $num_max < $min_agree )) && echo "Not enough agreements for Num Days" > /dev/stderr

  agreements=$day_max
  if (( $day_max >= $min_agree && $aff_max >= $min_agree && $num_max >= $min_agree )) &&
     [[ $day_answer && $aff_answer && $num_answer ]]; then
     agreements=$day_max
     [ $aff_max -lt $agreements ] && agreements=$aff_max
     [ $num_max -lt $agreements ] && agreements=$num_max
    $verbose && echo "Agreed upon answers (got $agreements of $min_agree): $day_answer, $aff_answer, $num_answer" > /dev/stderr
    local json="{\"day\":\"$day_answer\",\"is_affected\":$aff_answer,\"num_days\":$num_answer,\"agreements\":$agreements,\"min_agree\":$min_agree,\"run_count\":$run_count,\"error\":false}"
    echo "$json" | jq -r > /dev/null
    ret=$?
    $debug && printf "Agreement Check Answer JSON: " > /dev/stderr && echo "$json" | jq -c > /dev/stderr
    [ $ret != 0 ] && echo "Error: Invalid JSON in agreement check ($json)" > /dev/stderr && exit 1
    echo "$json" | jq -c
    return $ret
  fi
  return 1
}

# Function to run the LLM engine
run_engine() {
  local engine=${1:-localai}
  [[ ! " ${supported_engines[@]} " =~ " $engine " ]] && return
  ! $run_all && [[ $answer_json ]] && { $verbose&&echo "[$engine] Answer already set agreed upon">/dev/stderr;true; } && return
  declare -n ref=$engine

  ! ${ref[enabled]} && { $verbose&&echo "$engine disabled">/dev/stderr;true; } && return
  [[ ! "${ref[url]}" ]] && { $verbose&&echo "$engine url not set">/dev/stderr;true; } && return
  [[ $engine =~ ^(localai|ollama|chatgpt|claude|gemini|openrouter)$ && ! "${ref[model]}" ]] && return
  [[ $engine =~ ^(chatgpt|claude|gemini|mistral|openrouter)$ && ! "${ref[api_key]}" ]] && return
  [[ $engine =~ ^(mistral)$ && ! "${ref[agent_id]}" && ! "${ref[model]}" ]] && return
  [ -n "${ref[model]}" ] && ref[url]="${ref[url]//%%MODEL%%/${ref[model]}}"
  [ -n "${ref[agent_id]}" ] && unset ref[model]

  local api_header_switch api_header add_header_switch add_header message_content is_affected delay_days day
  if [ -n "${ref[api_key]}" ]; then
    api_header_switch="-H "
    case "$engine" in
      claude)
        api_header="x-api-key: ${ref[api_key]}"
        add_header_switch="-H "
        add_header="anthropic-version: ${ref[anthropic_version]}"
        ;;
      gemini)
        api_header="x-goog-api-key: ${ref[api_key]}"
        ;;
      *) api_header="Authorization: Bearer ${ref[api_key]}" ;;
    esac
  fi

  # Actually run against model
  oifs=$IFS
  IFS='|'
  models="${ref[model]}"
  $verbose && echo "$engine model order: ${models//|/ }" > /dev/stderr
  for model in $models; do
    IFS=$oifs
    $verbose && echo "Using $engine LLM${model:+ with $model}${ref[agent_id]:+ with an engine agent id}" > /dev/stderr
    case "$engine" in
      chatgpt)
        message_content='{
          "input": $user_message
        }'
        ;;
      claude|github|openrouter)
        message_content='{
          "messages": [
            {
              "role": "user",
              "content": $user_message
            }
          ]
        }'
        ;;
      gemini)
        message_content='{
          "contents": [
            {
              "parts": [
                {
                  "text": $user_message
                }
              ]
            }
          ]
        }'
        # Determine if model supports thinking (and is gemini-3)
        if [[ $model =~ ^gemini-[3-9] ]]; then
          t="${ref[url]%:*Content}"
          thinking=$(curl -s "$t?key=${ref[api_key]}" | jq -r '.thinking')
          [ "$thinking" != true ] && thinking=false

          $thinking && [ -n "${ref[thinking_level]}" ] && \
          message_content=$({
              jq -n --arg user_message "$user_message" "$message_content"
              jq -n '{
              "generationConfig": {
                "thinkingConfig": {
                  "thinkingLevel": "'${ref[thinking_level]:-low}'"
                }
              }
            }'
            } | jq -s add)
        fi
        ;;
      localai)
        message_content='{
          "messages": [
            {
              "role": "user",
              "reasoning": "'${ref[reasoning_level]:-low}'",
              "content": $user_message
            }
          ]
        }'
        ;;
      mistral)
        message_content='{
          "inputs": [
            {
              "role": "user",
              "content": $user_message
            }
          ]
        }'
        if [ -n "${ref[agent_id]}" ]; then
          message_content=$({
            jq -n --arg user_message "$user_message" "$message_content"
            jq -n '{"agent_id": "'${ref[agent_id]}'"}'
          } | jq -s add)
        fi
        ;;
      ollama)
        message_content='{
          "stream": false,
          "prompt": $user_message
        }'
        ;;
    esac
    [ -z "$message_content" ] && echo "Error: Could not generate message_content for LLM" && exit 1
    message_content=$(jq -n --arg user_message "$user_message" "$message_content")

    local data=$(jq -n \
      --arg max_tokens "${ref[max_tokens]}" \
      --arg prompt "${ref[prompt]}" \
      --arg model "$model" \
      'if $model != "" then . + {model: $model} else . end
      | if $max_tokens != "" then . + {max_tokens: ($max_tokens|tonumber)} else . end
      | if $prompt != "" then . + {prompt: $prompt} else . end
      ')
    [[ "$data" == "null" ]] && data="{}"
    data=$(jq -s '.[0] * .[1]' <(echo $data) <(echo "$message_content"))
    $debug && { echo "JSON data for curl:" && echo "$data" | sed 's/^/  /'; } > /dev/stderr
    $debug && set -x
    local starttime=$(date +%s)
    local tmpanswer=$(curl -s "${ref[url]}" \
      $api_header_switch${api_header:+"$api_header"} $add_header_switch${add_header:+"$add_header"} \
      -H "Content-Type: application/json" -d "$data")
    local endtime=$(date +%s)
    $debug && set +x
    $debug && echo "$engine ($model) output: $tmpanswer" > /dev/stderr
    tmpanswer=$(echo "$tmpanswer" | jq -r "${ref[match]}")
    $debug && echo "$engine ($model) post-jq-engine-match output: $tmpanswer" > /dev/stderr
    tmpanswer="${tmpanswer#*</think>}"
    tmpanswer=$(echo "$tmpanswer" | \
      sed -r 's/\[([0-9]),\s*[0-9]\]/\1/g;/^```/d;s/[][]//g' | \
      jq -Mr '"is_affected=\(.is_affected) delay_days=\(.delay_days)"')
    ret=$?
    $debug && echo "$engine ($model) post-jq output: $tmpanswer" > /dev/stderr
    ((run_count++))
    unset is_affected delay_days day
    if [ $ret != 0 ]; then
      tmpanswer="Bad json output"
    else
      if [[ $tmpanswer =~ ^is_affected=(true|false)" "delay_days=[0-6]$ ]]; then
        eval "$tmpanswer"
        day=$(date -d @$(( $(date -d $reference_ymd +%s) + $delay_days * 86400 )) +%A)
        # Fix is_affected if wrong, but everything else matches
        [ $day = $normal_recycle_day ] && [ $delay_days = 0 ] && [ $is_affected = true ] && is_affected=false
      else
        day="Invalid json format: $tmpanswer"
      fi
    fi

    if [[ $day ]]; then
      $verbose && echo "$engine ($model) answer: '$day/$is_affected/$delay_days'" > /dev/stderr
      responses_json=$(add_to_json_array "$responses_json" '  {
        "engine": "'$engine'",
        "model": "'$model'",
        "process_seconds": '$((endtime - starttime))',
        "day": "'$day'",
        "is_affected": '$is_affected',
        "num_days": '$delay_days'
      }')
      answer_json=$(check_agreement)
      [ $? != 0 ] && $debug && echo "No agreement after $answer_json" > /dev/stderr
      $debug && echo "Check Agreement Result answer_json = $answer_json" > /dev/stderr
      [ -n "$answer_json" ] && ! $run_all && return
    fi
  done
  IFS=$oifs
  unset -n ref
}

# Execute functions for LLMS
$verbose && echo "Running engines in this order: $engine_order" > /dev/stderr
$verbose && echo "Checking $model_count (need $min_agree to agree)" > /dev/stderr

for engine in $engine_order; do
  run_engine $engine
done

if [[ $answer_json && $responses_json ]]; then
  if ! echo "$answer_json" | jq -c > /dev/null; then
    echo "Error: Invalid Answer JSON ($answer_json)" > /dev/stderr
    exit 1
  fi
  if ! echo "$responses_json" | jq -c > /dev/null; then
    echo "Error: Invalid Responses JSON ($responses_json)" > /dev/stderr
    exit 1
  fi
  if $output_json; then
    jq -nr --argjson a "$answer_json" --argjson r "$responses_json" \
      '{ "day": "\($a.day)", "answer": $a, "responses": $r}'
    [ $? != 0 ] && echo "Error: Cannot build json from answers" && exit 1
    exit 0
  else
    echo "$json" | jq -r '.day'
    exit 0
  fi
else
  echo '{'
  echo '  "day": "Friday",'
  echo '  "answer": {'
  echo '    "day": "Friday",'
  echo '    "is_affected": false,'
  echo '    "num_days": 0,'
  echo '    "agreements": '"$agreements"','
  echo '    "min_agree": '"$min_agree"','
  echo '    "run_count": '"$run_count"','
  echo '    "error": true'
  echo '  },'
  echo '  "responses": []'
  echo '}'
  $verbose && echo "Error: Could not determine answer" > /dev/stderr
  $verbose && echo "       Answer JSON: $answer_json" > /dev/stderr
  $verbose && echo "       Responses JSON: $responses_json" > /dev/stderr
  exit 1
fi

