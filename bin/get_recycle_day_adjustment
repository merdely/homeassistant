#!/usr/bin/env bash

for f in curl jq; do
  ! command -v $f &> /dev/null && echo "Error: The '$f' command is required" > /dev/stderr && exit 1
done

debug=${debug:-false}
debug_exit=${debug_exit:-false}
verbose=${verbose:-false}
output_json=${output_json:-false}
today_date=$(date "+%Y-%m-%d")

secrets_file="${secrets_file:-$(readlink -f $(dirname "$0")/../secrets.yaml)}"

declare -A answers count

[ ! -r "$secrets_file" ] && echo "Error: Cannot open secrets file" && exit 1
! grep -q "^recycle_day_" "$secrets_file" && echo "Error: No recycle_day secrets in secrets file" && exit 1

for var in home_assistant_base_url recycle_url_main recycle_default_day; do
  [[ ! "${!var}" ]] && declare "$var=$(awk "/^$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print}" "$secrets_file")"
  [[ $var == home_assistant_base_url ]] && [[ ! $home_assistant_base_url ]] && home_assistant_base_url=http://localhost:8123
  [[ $var == recycle_url_main ]] && [[ ! $recycle_url_main ]] && recycle_url_main=https://www.montgomerycountymd.gov/DEP/trash-recycling/index.html
  [[ $var == recycle_default_day ]] && [[ ! $recycle_default_day ]] && recycle_default_day=Friday
done
for var in min_agree ollama_enabled ollama_model ollama_url ollama_api_key localai_enabled localai_model localai_prompt localai_url localai_api_key claude_enabled claude_model claude_api_key mistral_enabled mistral_api_key mistral_agent_id chatgpt_enabled chatgpt_model chatgpt_api_key hass_api_key; do
  [[ ! "${!var}" ]] && declare "$var=$(awk "/^recycle_day_$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print}" "$secrets_file")"
  [[ $var =~ _enabled$ ]] && [[ ${!var} != true || ! "${!var}" ]] && declare "$var=false"
  [[ $var == min_agree ]] && [[ ! $min_agree ]] && min_agree=2
done
[[ $answer ]] && min_agree=1 && answers[manual]=$answer

usage() {
  echo "usage: $(basename $0) [-h] [-d|-D] [-v] [-j] [-t TESTDATE] [-a ANSWER] [-m MIN_AGREE] [ENGINE] [MODEL]"
  echo "  -d           : Print debug information"
  echo "  -D           : Print debug information and exit"
  echo "  -v           : Be verbose"
  echo "  -j           : Output using JSON"
  echo "  -J           : Output simple response (i.e. 'Friday')"
  echo "  -t TESTDATE  : Use a test date instead of today (must be YYYY-mm-dd)"
  echo "  -a ANSWER    : Hardcode an answer"
  echo "  -m MIN_AGREE : Minimum number of LLMs must agree on answer (default: $min_agree)"
  echo "  ENGINE can one of: localai, ollama, mistral, claude, or chatgpt"
  echo "  MODEL has not been implemented yet"
  exit $1
}

while getopts ":hdDvJjt:a:m:" opt; do
  case $opt in
    d) debug=true ;;
    D) debug=true ; debug_exit=true ;;
    v) verbose=true ;;
    j) output_json=true ;;
    J) output_json=false ;;
    a) answer=$OPTARG ;;
    t)
       if [[ $OPTARG =~ ^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$ ]]; then
         today_date=$(date -d "$OPTARG" "+%Y-%m-%d")
         [ $? != 0 ] && echo "Error: Could not use date '$OPTARG'" && exit 1
       else
         echo "Error: Invalid date format ($OPTARG)"
         exit 1
       fi
       ;;
    m)
       [[ ! $OPTARG =~ ^[0-9]+$ ]] && echo "Error: MIN_AGREE must be a number" && exit 1
       min_agree=$OPTARG ;;
    *) usage ;;
  esac
done
shift $((OPTIND -1))

if [ -n "$1" ]; then
  localai_enabled=false
  ollama_enabled=false
  mistral_enabled=false
  claude_enabled=false
  chatgpt_enabled=false
  min_agree=1
  case "$1" in
    localai) localai_enabled=true ;;
    ollama)  ollama_enabled=true ;;
    mistral) mistral_enabled=true ;;
    claude)  claude_enabled=true ;;
    chatgpt) chatgpt_enabled=true ;;
    * ) echo "Error: Invalid AI engine (must be: localai, ollama, mistral, claude, or chatgpt" && exit 1 ;;
  esac
fi

unset use_model
[ -n "$2" ] && use_model=$2

[[ ! $hass_api_key ]] && echo "Error: Cannot determine hass_api_key from $secrets_file" && exit 1

use_ai=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_boolean.use_ai_for_recycle_day | jq -r .state)
if [ "${use_ai,,}" != "on" ]; then
  $debug && echo "Warning: Use AI for Recycle Day is not 'on' in Home Assistant" > /dev/stderr
  exit
fi
normal_recycle_day=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_select.recycle_day | jq -r .state)
[[ ! $normal_recycle_day ]] && normal_recycle_day=$recycle_default_day

if [ "$(date -d "$today_date" +%A)" = Sunday ]; then
  reference_date="${reference_date:-$(date -d "$today_date" "+%A, %B %_d, %Y")}"
else
  reference_date="${reference_date:-$(date -d "@$(( $(date -d "$today_date" +%s) - $(date -d "$today_date" +%w)*86400 ))" "+%A, %B %_d, %Y")}"
fi
reference_date=${reference_date//  / }

xmllint=false
command -v xmllint &> /dev/null && xmllint=true
if $xmllint; then
  county_alert_url=$(curl -sL $recycle_url_main | \
    xmllint --html --xpath 'string(//div[@id="alert"]/following-sibling::script)' - 2>/dev/null | \
    sed -n 's/.*load("\([^"]*\)".*/\1/p')
else
  county_alert_url=$(curl -sL $recycle_url_main | \
    sed -n 's/.*$("#alert").load("\([^"]*\)".*/\1/p')
fi

if $xmllint && [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL $county_alert_url | xmllint --html --xpath 'string(//body)' - 2> /dev/null | \
    sed -r 's/^\s*//;/^\s*$/d' | paste -sd " ")
elif [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL "$county_alert_url" | \
    sed -r ':a;N;$!ba;s/\n/ /g;s/(&nbsp;|\r)/ /g;s/<!--.*-->//g;s/ +/ /g;s/<[^>]*>//g;s/^ +//')
else
  echo "Warning: Invalid MoCo Alert/Warning URL ($county_alert_url)" > /dev/stderr
fi

# user_message="My normal recycling pickup weekday is $normal_recycle_day and today is $reference_date. $county_alert_text If nothing so far has indicated that the recycling will change this week, then the day the county will pick up my recycle should be the normal recycling pickup weekday. Without explaining how you arrived at your conclusion, what weekday will the county come to pick up my recycle this week?"
user_message=${user_message:-My normal recycling pickup weekday is $normal_recycle_day and today is $reference_date. $county_alert_text If nothing so far has indicated that the recycling will change this week, then the day the county will pick up my recycle should be the normal recycling pickup weekday. Briefly tell me which weekday will the county come to pick up my recycle this week?}
user_message=${user_message/// }

day_search='\b([Ss]un|[Mm]on|[Tt]ues|[Ww]ednes|[Tt]hurs|[Ff]ri|[Ss]atur)day\b'

if $debug; then
  for var in home_assistant_base_url hass_api_key recycle_url_main county_alert_url recycle_default_day normal_recycle_day today_date reference_date min_agree user_message localai_enabled localai_url localai_model localai_prompt localai_api_key ollama_enabled ollama_url ollama_model ollama_api_key claude_enabled claude_model claude_api_key mistral_enabled mistral_api_key mistral_agent_id chatgpt_enabled chatgpt_model chatgpt_api_key; do
    $debug && printf '%s=%s\n' "$var" "${!var}"
  done
  $debug_exit && exit
fi

check_agreement() {
  #set -o xtrace
  [[ $min_agree = 1 ]] && [[ ${#answers[@]} = 1 ]] && echo ${answers[@]} && return 0

  local count
  local max=0
  local answer=""
  declare -A count

  $debug && echo "methods = ${!answers[@]}" > /dev/stderr
  $debug && echo "answers = ${answers[@]}" > /dev/stderr
  for v in "${answers[@]}"; do [[ $v ]] && ((count["$v"]++)); done
  for v in "${!count[@]}"; do (( count[$v] > max )) && max=${count[$v]} && answer=$v; done
  (( $max < $min_agree )) && return 1
  [[ ! $answer ]] && return 1
  echo $answer
}

localai() {
  [[ $answer ]] && return
  ! $localai_enabled && return
  [[ ! $localai_model ]] && return
  [[ ! $localai_url ]] && return
  $verbose && echo "Using Local AI LLM with ${use_model:-$localai_model}" > /dev/stderr
  unset api_header_switch api_header
  if [ -n "$localai_api_key" ]; then
    api_header_switch="-H "
    api_header="Authorization: Bearer $localai_api_key"
  fi
  if [ -n "$localai_prompt" ]; then
    localai_prompt=${localai_prompt#\"}
    localai_prompt="\"prompt\": \"${localai_prompt%\"}\","
  fi
  data="{
        \"max_tokens\": 8192,
        $localai_prompt
        \"messages\": [
          {
            \"role\": \"user\",
            \"reasoning\": \"low\",
            \"content\": \"$user_message\"
          }
        ],
        \"model\": \"${use_model:-$localai_model}\"
      }"
  $debug && echo "$data" > /dev/stderr
  tmpanswer=$(curl -s $localai_url/v1/chat/completions $api_header_switch"$api_header" \
    -H "content-type: application/json" -d "$data")
  $debug && echo "Local AI output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | jq -r '.choices[0].message.reasoning // .choices[0].message.content')
  $debug && echo "Local AI post-jq output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | grep -oE "$day_search" | tail -n1)

  unset api_header_switch api_header
  if [[ $tmpanswer ]]; then
    $verbose && echo "Local AI answer: $tmpanswer" > /dev/stderr
    answers[localai]=$tmpanswer
    answer=$(check_agreement)
    [ $? != 0 ] && $debug && echo "No agreement after ${!answers[@]}"
  fi
}

ollama() {
  [[ $answer ]] && return
  ! $ollama_enabled && return
  [[ ! $ollama_model ]] && return
  [[ ! $ollama_url ]] && return

  $verbose && echo "Using Ollama LLM with ${use_model:-$ollama_model}" > /dev/stderr
  unset api_header_switch api_header
  if [ -n "$ollama_api_key" ]; then
    api_header_switch="-H "
    api_header="Authorization: Bearer $ollama_api_key"
  fi
  data="{
        \"model\": \"${use_model:-$ollama_model}\",
        \"prompt\": \"$user_message\",
        \"stream\": false
      }"
  $debug && echo "$data" > /dev/stderr
  tmpanswer=$(curl -s $ollama_url/api/generate $api_header_switch -d "$data")
  $debug && echo "Ollama output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | jq -r '.response')
  $debug && echo "Ollama post-jq output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | grep -oE "$day_search" | tail -n1)

  unset api_header_switch api_header
  if [[ $tmpanswer ]]; then
    $verbose && echo "Ollama answer: $tmpanswer" > /dev/stderr
    answers[ollama]=$tmpanswer
    answer=$(check_agreement)
    [ $? != 0 ] && $debug && echo "No agreement after ${!answers[@]}"
  fi
}

mistral() {
  [[ $answer ]] && return
  ! $mistral_enabled && return
  [[ ! $mistral_api_key ]] && return
  [[ ! $mistral_agent_id ]] && return
  $verbose && echo "Using Mistral LLM" > /dev/stderr
  [ -z "$mistral_api_key" ] && echo "Error: Cannot use Mistral: No API key in $secrets_file" && exit 1
  data="{
          \"agent_id\": \"$mistral_agent_id\",
          \"inputs\": [
            {\"role\":\"user\",\"content\":\"$user_message\"}
          ]
        }"
  tmpanswer=$(curl -s https://api.mistral.ai/v1/conversations \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $mistral_api_key" -d "$data")
  $debug && echo "Mistral output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | jq -r '.outputs[0].content')
  $debug && echo "Mistral post-jq output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | grep -oE "$day_search" | tail -n1)

  if [[ $tmpanswer ]]; then
    $verbose && echo "Mistral answer: $tmpanswer" > /dev/stderr
    answers[mistral]=$tmpanswer
    answer=$(check_agreement)
    [ $? != 0 ] && $debug && echo "No agreement after ${!answers[@]}"
  fi
}

claude() {
  [[ $answer ]] && return
  ! $claude_enabled && return
  [[ ! $claude_model ]] && return
  [[ ! $claude_api_key ]] && return
  $verbose && echo "Using Claude LLM" > /dev/stderr
  [ -z "$claude_api_key" ] && echo "Error: Cannot use Claude: No API key in $secrets_file" && exit 1
  data="{
          \"model\": \"$claude_model\",
          \"max_tokens\": 100,
          \"messages\": [
            {\"role\": \"user\", \"content\": \"$user_message\"}
          ]
        }"
  tmpanswer=$(curl -s https://api.anthropic.com/v1/messages \
    -H "x-api-key: $claude_api_key" \
    -H "anthropic-version: 2023-06-01" \
    -H "content-type: application/json" -d "$data")
  $debug && echo "Claude output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | jq -r '.content[0].text')
  $debug && echo "Claude post-jq output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | grep -oE "$day_search" | tail -n1)

  if [[ $tmpanswer ]]; then
    $verbose && echo "Claude answer: $tmpanswer" > /dev/stderr
    answers[claude]=$tmpanswer
    answer=$(check_agreement)
    [ $? != 0 ] && $debug && echo "No agreement after ${!answers[@]}"
  fi
}

chatgpt() {
  [[ $answer ]] && return
  ! $chatgpt_enabled && return
  [[ ! $chatgpt_model ]] && return
  [[ ! $chatgpt_api_key ]] && return
  $verbose && echo "Using ChatGPT LLM" > /dev/stderr
  [ -z "$chatgpt_api_key" ] && echo "Error: Cannot use ChatGPT: No API key in $secrets_file" && exit 1
  data="{
          \"model\": \"$chatgpt_model\",
          \"input\": \"$user_message\"
        }"
  tmpanswer=$(curl -s https://api.openai.com/v1/responses \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $chatgpt_api_key" -d "$data")
  $debug && echo "Claude output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | jq -r '.output[0].content[0].text')
  $debug && echo "Claude post-jq output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | grep -oE "$day_search" | tail -n1)

  if [[ $tmpanswer ]]; then
    $verbose && echo "ChatGPT answer: $tmpanswer" > /dev/stderr
    answers[chatgpt]=$tmpanswer
    answer=$(check_agreement)
    [ $? != 0 ] && $debug && echo "No agreement after ${!answers[@]}"
  fi
}

# Execute functions for LLMS
localai
ollama
mistral
claude
chatgpt

if [[ $answer ]]; then
  if $output_json; then
    echo "{"
    if [ ${#answers[@]} != 0 ]; then
      comma=,
      count=0
      echo "  \"answers\": {"
      for v in "${!answers[@]}"; do
        ((count++))
        (( count >= ${#answers[@]} )) && unset comma
        echo "    \"$v\": \"${answers[$v]}\"$comma"
      done
      echo "  },"
    fi
    echo "  \"answer\": \"$answer\""
    echo "}"
  else
    echo $answer
  fi
elif [ ${#answers[@]} = 0 ]; then
  echo "Error: No LLMs were used to determine date (none configured?)"
else
  echo "Error: Could not determine answer"
  exit 1
fi

