#!/usr/bin/env bash

for f in curl jq; do
  ! command -v $f &> /dev/null && echo "Error: The '$f' command is required" > /dev/stderr && exit 1
done

supported_engines="localai|ollama|chatgpt|claude|mistral"
debug="${debug:-false}"
extra_debug="${extra_debug:-false}"
verbose="${verbose:-false}"
extra_verbose="${extra_verbose:-false}"
output_json="${output_json:-false}"
today_date="$(date "+%Y-%m-%d")"
chatgpt_url="${chatgpt_url:-https://api.openai.com/v1/responses}"
claude_url="${claude_url:-https://api.anthropic.com/v1/messages}"
claude_max_tokens="${claude_max_tokens:-100}"
mistral_url="${mistral_url:-https://api.mistral.ai/v1/conversations}"
anthropic_version="${anthropic_version:-2023-06-01}"
engine_order="${engine_order:-localai ollama chatgpt claude mistral}"

secrets_file="${secrets_file:-$(readlink -f $(dirname "$0")/../secrets.yaml)}"

declare -A answers count

# Validate secrets file
[ ! -r "$secrets_file" ] && echo "Error: Cannot open secrets file" && exit 1
! grep -q "^recycle_day_" "$secrets_file" && echo "Error: No recycle_day secrets in secrets file" && exit 1

# Get common settings
for var in home_assistant_base_url recycle_url_main recycle_default_day ; do
  [[ ! "${!var}" ]] && declare "$var=$(awk "/^$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")"
  declare "$var=${!var# }"  # Trim space
  declare "$var=${!var% }"  # Trim space
  declare "$var=${!var#\"}"  # Trim quote
  declare "$var=${!var%\"}"  # Trim quote
  declare "$var=${!var#\'}"  # Trim quote
  declare "$var=${!var%\'}"  # Trim quote
  [[ $var == home_assistant_base_url ]] && [[ ! $home_assistant_base_url ]] && home_assistant_base_url=http://localhost:8123
  [[ $var == recycle_url_main ]] && [[ ! $recycle_url_main ]] && recycle_url_main=https://www.montgomerycountymd.gov/DEP/trash-recycling/index.html
  [[ $var == recycle_default_day ]] && [[ ! $recycle_default_day ]] && recycle_default_day=Friday
done

# Get program settings that do not overwrite previous values
for var in hass_api_key min_agree localai_enabled localai_url localai_model localai_prompt localai_api_key ollama_enabled ollama_url ollama_model ollama_api_key chatgpt_enabled chatgpt_model chatgpt_api_key claude_enabled claude_model claude_api_key mistral_enabled mistral_api_key mistral_agent_id ; do
  [[ ! "${!var}" ]] && declare "$var=$(awk "/^recycle_day_$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")"
  declare "$var=${!var# }"  # Trim space
  declare "$var=${!var% }"  # Trim space
  declare "$var=${!var#\"}"  # Trim quote
  declare "$var=${!var%\"}"  # Trim quote
  declare "$var=${!var#\'}"  # Trim quote
  declare "$var=${!var%\'}"  # Trim quote
  [[ $var =~ _enabled$ ]] && [[ ${!var} != true || ! "${!var}" ]] && declare "$var=false"
  [[ $var == min_agree ]] && [[ ! $min_agree ]] && min_agree=2
done
[[ $answer ]] && min_agree=1 && answers[manual]=$answer

# Get program settings that do overwrite previous values
for var in engine_order localai_max_tokens localai_match ollama_max_tokens ollama_match chatgpt_url chatgpt_max_tokens chatgpt_match claude_max_tokens claude_url claude_match mistral_url mistral_max_tokens mistral_match ; do
  tmpval=$(awk "/^recycle_day_$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")
  [[ $tmpval ]] && declare "$var=$tmpval"
  declare "$var=${!var# }"  # Trim space
  declare "$var=${!var% }"  # Trim space
  declare "$var=${!var#\"}"  # Trim quote
  declare "$var=${!var%\"}"  # Trim quote
  declare "$var=${!var#\'}"  # Trim quote
  declare "$var=${!var%\'}"  # Trim quote
  unset tmpval
done

usage() {
  echo "usage: $(basename $0) [-h] [-d] [-v] [-j] [-t TESTDATE] [-a ANSWER] [-m MIN_AGREE]"
  echo "                      [ENGINELIST] [MODELLIST]"
  echo "  -d           : Print debug information (second -d exits after printing)"
  echo "  -v           : Be verbose (second -v is extra verbose)"
  echo "  -j           : Output using JSON"
  echo "  -J           : Output simple response (i.e. 'Friday')"
  echo "  -t TESTDATE  : Use a test date instead of today (must be YYYY-mm-dd)"
  echo "  -a ANSWER    : Hardcode an answer"
  echo "  -m MIN_AGREE : Minimum number of LLMs must agree on answer (default: $min_agree)"
  echo
  echo "  ENGINELIST can one or more of: ${supported_engines[@]//|/ }"
  echo "  If specified, MODELLIST must be: A list of models that would have to match the ENGINE list"
  echo "  The first engine given would be matched with the first model given"
  echo "  ENGINELIST and MODELLIST are space separated on the command line"
  echo "  If MODELLIST is empty and ENGINELIST is set, models will be used from $secrets_file"
  echo "  Examples:"
  echo "    $(basename $0) -j ollama gemma3:4b localai gemma-3-4b-it"
  echo "    $(basename $0) -j ollama localai gemma3:4b gemma-3-4b-it"
  echo "    $(basename $0) -j gemma3:4b gemma-3-4b-it ollama localai"
  exit $1
}

while getopts ":hdvJjt:a:m:" opt; do
  case $opt in
    d)
       $debug && extra_debug=true
       debug=true ;;
    v)
       $verbose && extra_verbose=true
       verbose=true
       ;;
    j) output_json=true ;;
    J) output_json=false ;;
    a) answer=$OPTARG ; answers[commandline]=$answer; answers[given]=$answer;;
    t)
       if [[ $OPTARG =~ ^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$ ]]; then
         today_date=$(date -d "$OPTARG" "+%Y-%m-%d")
         [ $? != 0 ] && echo "Error: Could not use date '$OPTARG'" && exit 1
       else
         echo "Error: Invalid date format ($OPTARG)"
         exit 1
       fi
       ;;
    m)
       [[ ! $OPTARG =~ ^[0-9]+$ ]] && echo "Error: MIN_AGREE must be a number" && exit 1
       min_agree=$OPTARG ;;
    *) usage ;;
  esac
done
shift $((OPTIND -1))

engines=()
models=()
while [ -n "$1" ]; do
  if [[ $1 =~ ^($supported_engines)$ ]]; then
    engines+=($1)
  else
    models+=($1)
  fi
  shift
done
if [ ${#engines[@]} -gt 0 ]; then
  for engine in ${supported_engines//|/ }; do
    declare "${engine}_enabled=false"
  done
  for engine in "${engines[@]}"; do
    declare "${engine}_enabled=true"
  done
  engine_order="${engines[@]}"
fi
if [ ${#engines[@]} -gt 1 ]; then
  if [ ${#models[@]} -eq 1 ]; then
    for engine in "${engines[@]}"; do
      echo "${engine}_model=${models[0]}"
      declare "${engine}_model=${models[0]}"
    done
  elif [ ${#engines[@]} -eq ${#models[@]} ]; then
    for i in $(seq 0 $((${#engines[@]} - 1))); do
      echo "${engines[$i]}_model=${models[$i]}"
      declare "${engines[$i]}_model=${models[$i]}"
    done
  else
    if [ ${#models[@]} -ne 0 ]; then
      echo "Error: Engine/Model mismatch. The same number of engines and models must be passed." > /dev/stderr
      echo > /dev/stderr
      usage 1
    fi
  fi
elif [ ${#engines[@]} -eq 1 ]; then
  min_agree=1
  if [ ${#models[@]} -eq 1 ]; then
    declare "${engine}_model=${models[0]}"
  else
    if [ ${#models[@]} -ne 0 ]; then
      echo "Error: Engine/Model mismatch. The same number of engines and models must be passed." > /dev/stderr
      echo > /dev/stderr
      usage 1
    fi
  fi
fi

# Get whether Home Assistant toggle for using AI is enabled
[[ ! $hass_api_key ]] && echo "Error: Cannot determine hass_api_key from $secrets_file" && exit 1
use_ai=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_boolean.use_ai_for_recycle_day | jq -r .state)
if [ "${use_ai,,}" != "on" ]; then
  $debug && echo "Warning: Use AI for Recycle Day is not 'on' in Home Assistant" > /dev/stderr
  exit
fi

# Get normal recycle day from Home Assistant
normal_recycle_day=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_select.recycle_day | jq -r .state)
[[ ! $normal_recycle_day ]] && normal_recycle_day=$recycle_default_day
$verbose && echo "Normal recycle day: $normal_recycle_day" > /dev/stderr

# Set reference day to the normal recycle day for this week (or of the passed week)
epoch=$(date ${today_date:+-d $today_date} +%s)
dow=$(date ${today_date:+-d $today_date} +%w)
reference_date=$(date -d "@$(( epoch + (5 - dow) * 86400 ))" +"%A, %B %-d")
reference_ymd=$(date -d "@$(( epoch + (5 - dow) * 86400 ))" +"%Y-%m-%d")
$verbose && echo "Reference date: $reference_date ($reference_ymd)" > /dev/stderr

# Determine the URL for the county's alert text on the recycle URL
xmllint=false
command -v xmllint &> /dev/null && xmllint=true
if $xmllint; then
  county_alert_url=$(curl -sL $recycle_url_main | \
    xmllint --html --xpath 'string(//div[@id="alert"]/following-sibling::script)' - 2>/dev/null | \
    sed -n 's/.*load("\([^"]*\)".*/\1/p')
else
  county_alert_url=$(curl -sL $recycle_url_main | \
    sed -n 's/.*$("#alert").load("\([^"]*\)".*/\1/p')
fi
$verbose && echo "County Alert URL: $county_alert_url" > /dev/stderr

# Determine the content of the county's alert text
if $xmllint && [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL $county_alert_url | xmllint --html --xpath 'string(//body)' - 2> /dev/null | \
    sed -r 's/^\s*//;/^\s*$/d' | paste -sd " ")
elif [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL "$county_alert_url" | \
    sed -r ':a;N;$!ba;s/\n/ /g;s/(&nbsp;|\r)/ /g;s/<!--.*-->//g;s/ +/ /g;s/<[^>]*>//g;s/^ +//')
else
  echo "Warning: Invalid MoCo Alert/Warning URL ($county_alert_url)" > /dev/stderr
fi
if $extra_verbose; then
  echo "County Notice:"
  echo "    $county_alert_text" | fold -sw $((COLUMNS - 4)) | sed "2,\$s/^/$(printf '%*s' 4)/"
elif $verbose; then
  width=$((COLUMNS - 4))  # Number of columns - width of "County Notice: " - padding
  unset dots
  county_notice="$(echo "County Notice: \"$(echo "$county_alert_text" | paste -sd ' ')" | fold -sw $width | head -n1)"
  [ ${#county_alert_text} -gt $width ] && dots=…
  printf "%s%s\"\n" "$county_notice" "$dots"
fi

# Set the user message to send to the LLM
# user_message=${user_message:-My normal recycling pickup weekday is $normal_recycle_day and today is $reference_date. $county_alert_text If nothing so far has indicated that the recycling will change this week, then the day the county will pick up my recycle should be the normal recycling pickup weekday. Briefly tell me which weekday will the county come to pick up my recycle this week?}

#user_message="${user_message:-County website notice:
#\"${county_alert_text/// }\"
#
#For the date $reference_date, will my recycling pickup day change due to the county website notice? If yes, by how many days will it be delayed?
#
#Return your answer in the following format (do not add any extra text or explanation):
#{
#  \"date\": \"[INSERT_DATE]\",
#  \"is_affected\": [true/false],
#  \"delay_days\": [number of days delayed, or 0 if not affected]
#}}"
user_message="${user_message:-County website notice:
\"${county_alert_text/// }\"

Consider whether a recycling pickup on $reference_date is during the same week as any holiday mentioned in the notice, if it is on or after the holiday during that week, and if my recycling pickup day will change due to the county website notice. If yes, by how many days will it be delayed?

Return your answer in the following format (do not add any extra text or explanation):
{
  \"date\": \"[INSERT_DATE]\",
  \"is_affected\": [true/false],
  \"delay_days\": [number of days delayed, or 0 if not affected]
}}"

if $extra_verbose; then
  echo "LLM User Message:"
  echo "    $user_message" | fold -sw $((COLUMNS - 4)) | sed "2,\$s/^/$(printf '%*s' 4)/"
elif $verbose; then
  width=$((COLUMNS - 4))  # Number of columns - width of "County Notice: " - padding
  unset dots
  usermsg_text="$(echo "LLM User Message: \"$(echo "$user_message" | paste -sd ' ')" | fold -sw $width | head -n1)"
  [ ${#user_message} -gt $width ] && dots=…
  printf "%s%s\"\n" "$usermsg_text" "$dots"
fi

# The grep string used to find a day of the week
day_search='\b([Ss]un|[Mm]on|[Tt]ues|[Ww]ednes|[Tt]hurs|[Ff]ri|[Ss]atur)day\b'

# If debug mode, print variables
if $debug; then
  echo "Settings: " > /dev/stderr
  for var in secrets_file home_assistant_base_url hass_api_key recycle_url_main county_alert_url recycle_default_day normal_recycle_day today_date reference_date reference_ymd min_agree user_message engine_order localai_enabled localai_url localai_model local_ai_max_tokens localai_prompt localai_api_key localai_match ollama_enabled ollama_url ollama_model ollama_max_tokens ollama_api_key ollama_match chatgpt_enabled chatgpt_model chatgpt_max_tokens chatgpt_api_key chatgpt_match claude_enabled claude_model claude_max_tokens claude_api_key claude_match mistral_enabled mistral_max_tokens mistral_api_key mistral_agent_id mistral_match ; do
    [ $var = user_message ] && printf ' - %s = "%s"\n' "$var" "$(echo "${!var}" | fold -sw $((COLUMNS - ${#var} - 3))|sed "2,\$s/^/$(printf '%*s' $((${#var} - 3)))/")" > /dev/stderr
    ! [ $var = user_message ] && printf ' - %s = "%s"\n' "$var" "${!var}" > /dev/stderr
  done
  $extra_debug && exit
fi

# Function to check if the minimum number of LLMs agree on their answer
check_agreement() {
  [[ $min_agree = 1 ]] && [[ ${#answers[@]} = 1 ]] && echo ${answers[@]} && return 0

  local count
  local max=0
  local answer=""
  declare -A count

  $verbose && echo "Checking agreement with $min_agree agreements needed" > /dev/stderr
  $debug && echo "methods = ${!answers[@]}" > /dev/stderr
  $debug && echo "answers = ${answers[@]}" > /dev/stderr
  for v in "${answers[@]}"; do [[ $v ]] && ((count["$v"]++)); done
  for v in "${!count[@]}"; do (( count[$v] > max )) && max=${count[$v]} && answer=$v; done
  $verbose && echo "Agreements found: $max" > /dev/stderr
  (( $max < $min_agree )) && return 1
  [[ ! $answer ]] && return 1
  echo $answer
}

# Function to run the LLM engine
run_engine() {
  local engine=${1:-localai}

  local engine_enabled="${engine}_enabled"
  ! ${!engine_enabled} && { $verbose&&echo "$engine disabled">/dev/stderr;true; } && return
  [[ ! -v "${engine}_url" ]] && { $verbose&&echo "${engine_url} not set">/dev/stderr;true; } && return
  [[ $engine =~ ^(localai|ollama|chatgpt|claude)$ && ! -v "${engine}_model" ]] && return
  [[ $engine =~ ^(chatgpt|claude|mistral)$ && ! -v "${engine}_api_key" ]] && return
  [[ $engine =~ ^(mistral)$ && ! -v "${engine}_agent_id" ]] && return
  [[ $answer ]] && { $verbose&&echo "Answer already set to $answer">/dev/stderr;true; } && return

  local max_tokens="${engine}_max_tokens"
  local prompt="${engine}_prompt"
  local engine_url="${engine}_url"
  local engine_model="${engine}_model"
  local engine_match="${engine}_match"
  local engine_api_key engine_agent_id
  [ -v "${engine}_api_key" ] && engine_api_key="${engine}_api_key"
  [ -v "${engine}_agent_id" ] && engine_agent_id="${engine}_agent_id"
  $verbose && echo "Using $engine LLM${!engine_model:+ with ${!engine_model}}${!engine_agent_id:+ with an engine agent id}" > /dev/stderr

  local api_header_switch api_header add_header_switch add_header message_content
  if [ -v "${engine}_api_key" ]; then
    api_header_switch="-H "
    local engine_api_key="${engine}_api_key"
    case "$engine" in
      claude)
        api_header="x-api-key: ${!engine_api_key}"
        add_header_switch="-H "
        add_header="anthropic-version: $anthropic_version"
        ;;
      *) api_header="Authorization: Bearer ${!engine_api_key}" ;;
    esac
  fi
  case "$engine" in
    localai)
      message_content="\"messages\": [
          {
            \"role\": \"user\",
            \"reasoning\": \"low\",
            \"content\": \"$user_message\"
          }
        ]"
      message_content=$(jq -n --arg message "$user_message" '{messages:[{role:"user",reasoning:"low",content:$message}]}')
      ;;
    ollama)
      message_content="\"prompt\": \"$user_message\",
        \"stream\": false"
      message_content=$(jq -n --arg message "$user_message" '{prompt:$message,stream:false}')
      ;;
    chatgpt)
      message_content="\"input\": \"$user_message\""
      message_content=$(jq -n --arg message "$user_message" '{input:$message}')
      ;;
    claude)
      message_content="\"messages\": [
          {
            \"role\": \"user\",
            \"content\": \"$user_message\"
          }
        ]"
      message_content=$(jq -n --arg message "$user_message" '{messages:[{role:"user",content:$message}]}')
      ;;
    mistral)
      message_content="\"inputs\": [
          {
            \"role\": \"user\",
            \"content\": \"$user_message\"
          }
        ]"
      message_content=$(jq -n --arg message "$user_message" '{inputs:[{role:"user",content:$message}]}')
      ;;
  esac

  local data=$(jq -n \
    --arg max_tokens "${!max_tokens}" \
    --arg prompt "${!prompt}" \
    --arg model "${use_model:-${!engine_model}}" \
    --arg agent_id "${!engine_agent_id}" \
    'if $model != "" then . + {model: $model} else . end
    | if $agent_id != "" then . + {agent_id: $agent_id} else . end
    | if $max_tokens != "" then . + {max_tokens: ($max_tokens|tonumber)} else . end
    | if $prompt != "" then . + {prompt: $prompt} else . end
    ')
  [[ "$data" == "null" ]] && data="{}"
  data=$(jq -s '.[0] * .[1]' <(echo $data) <(echo "$message_content"))
  $debug && echo "$data" > /dev/stderr
  $debug && set -x
  local tmpanswer=$(curl -s "${!engine_url}" \
    $api_header_switch${api_header:+"$api_header"} $add_header_switch${add_header:+"$add_header"} \
    -H "Content-Type: application/json" -d "$data")
  $debug && set +x
  $debug && echo "$engine output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | jq -r "${!engine_match}")
  $debug && echo "$engine post-jq-engine-match output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | sed '/^```/d' | jq -Mr '"is_affected=\(.is_affected) delay_days=\(.delay_days)"')
  ret=$?
  $debug && echo "$engine post-jq output: $tmpanswer" > /dev/stderr
  local is_affected delay_days
  if [ $ret != 0 ]; then
    tmpanswer="Bad json output"
  else
    if [[ $tmpanswer =~ ^is_affected=(true|false)" "delay_days=[0-6]$ ]]; then
      eval "$tmpanswer"
      tmpanswer=$(date -d @$(( $(date -d $reference_ymd +%s) + $delay_days * 86400 )) +%A)
    else
      tmpanswer="Invalid json format: $tmpanswer"
    fi
  fi

  unset api_header_switch api_header
  if [[ $tmpanswer ]]; then
    $verbose && echo "$engine answer: '$tmpanswer'" > /dev/stderr
    answers[$engine]=$tmpanswer
    answer=$(check_agreement)
    [ $? != 0 ] && $debug && echo "No agreement after ${!answers[@]}" > /dev/stderr
  fi
}

# Execute functions for LLMS
$verbose && echo "Running engines in this order: $engine_order" > /dev/stderr

for engine in $engine_order; do
  run_engine $engine
done

if [[ $answer ]]; then
  if $output_json; then
    $verbose && echo "Answers contains: $(declare -p answers | sed -r 's/declare -[a-z]+ answers=//i;s/(\(|\) ?)//g')"
    json=$(for k in "${!answers[@]}"; do
      jq -n --arg k "$k" --arg v "${answers[$k]}" '{($k): $v}'
    done | jq -s add)
    [[ ! $json ]] && echo "Error: Cannot build json from answers" && exit
    jq -M -n --arg a "$answer" --argjson as "$json" '{"answers": $as, "answer": $a}'
  else
    echo $answer
  fi
elif [ ${#answers[@]} = 0 ]; then
  echo "Error: No LLMs were used to determine date (none configured?)"
else
  echo "Error: Could not determine answer"
  exit 1
fi

