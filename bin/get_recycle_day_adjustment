#!/usr/bin/env bash

for f in curl jq; do
  ! command -v $f &> /dev/null && echo "Error: The '$f' command is required" > /dev/stderr && exit 1
done

supported_engines=(chatgpt claude gemini github localai mistral ollama openrouter)
engine_settings=(enabled url api_key model prompt match max_tokens extra thinking_level agent_id)
declare -A ${supported_engines[@]}
debug="${debug:-false}"
extra_debug="${extra_debug:-false}"
debug_exit=false
verbose="${verbose:-false}"
extra_verbose="${extra_verbose:-false}"
output_json="${output_json:-false}"
today_date="$(date "+%Y-%m-%d")"

engine_order="${engine_order:-localai ollama mistral openrouter gemini claude chatgpt}"

declare -A url model match max_tokens thinking_level extra

chatgpt[url]="${chatgpt_url:-https://api.openai.com/v1/responses}"
chatgpt[model]="${chatgpt_model:-gpt-5-mini}"
chatgpt[match]="${chatgpt_match:-.output[0].content[0].text}"

claude[url]="${claude_url:-https://api.anthropic.com/v1/messages}"
claude[model]="${claude_model:-claude-sonnet-4-20250514}"
claude[max_tokens]="${claude_max_tokens:-100}"
claude[match]="${claude_match:-.content[0].text}"
claude[extra]="anthropic_version=${anthropic_version:-2023-06-01}|another_setting=a=1234%%PIPE%%5678|foobar=baz"

gemini[url]="${gemini_url:-https://generativelanguage.googleapis.com/v1beta/models/%%MODEL%%:generateContent}"
gemini[model]="${gemini_model:-gemini-3-flash-preview}"
gemini[thinking_level]="${gemini_thinking_level:-low}"
gemini[match]="${gemini_match:-.candidates[0].content.parts[0].text}"

github[url]="${github_url:-https://models.github.ai/inference/chat/completions}"
github[model]="${github_model:-microsoft/Phi-4-mini-reasoning}"
github[match]="${github_match:-.choices[0].message.content}"

mistral[url]="${mistral_url:-https://api.mistral.ai/v1/conversations}"
mistral[model]="${mistral_model:-mistral-medium-latest}"
mistral[match]="${mistral_match:-.outputs[0].content}"

openrouter[url]="${openrouter_url:-https://openrouter.ai/api/v1/chat/completions}"
openrouter[model]="${openrouter_model:-openai/gpt-5.2}"
openrouter[match]="${openrouter_match:-.output[0].content[0].text}"

secrets_file="${secrets_file:-$(readlink -f $(dirname "$0")/../secrets.yaml)}"

declare -A answers count

setvar() {
  local var=$1
  var=${var# }  # Trim space
  var=${var% }  # Trim space
  var=${var#\"}  # Trim quote
  var=${var%\"}  # Trim quote
  var=${var#\'}  # Trim quote
  var=${var%\'}  # Trim quote
  echo "$var"
}
# Validate secrets file

[ ! -r "$secrets_file" ] && echo "Error: Cannot open secrets file" && exit 1
! grep -q "^recycle_day_" "$secrets_file" && echo "Error: No recycle_day secrets in secrets file" && exit 1

# Get common settings
for var in home_assistant_base_url recycle_url_main recycle_default_day ; do
  [[ ! "${!var}" ]] && declare "$var=$(setvar "$(awk "/^$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")")"
  [[ $var == home_assistant_base_url ]] && [[ ! $home_assistant_base_url ]] && home_assistant_base_url=http://localhost:8123
  [[ $var == recycle_url_main ]] && [[ ! $recycle_url_main ]] && recycle_url_main=https://www.montgomerycountymd.gov/DEP/trash-recycling/index.html
  [[ $var == recycle_default_day ]] && [[ ! $recycle_default_day ]] && recycle_default_day=Friday
done

# Get general program settings that do not overwrite previous values
for var in hass_api_key min_agree ; do
  [[ ! "${!var}" ]] && declare "$var=$(setvar "$(awk "/^recycle_day_$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")")"
done
min_agree=${min_agree:-2}
[[ $answer ]] && min_agree=1 && answers[manual]=$answer

for var in engine_order ; do
  tmpval=$(awk "/^recycle_day_$var ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")
  [[ $tmpval ]] && declare "$var=$(setvar "$tmpval")"
  unset tmpval
done

# Get program settings that do overwrite previous values
for engine in ${supported_engines[@]}; do
  for setting in ${engine_settings[@]}; do
    tmpval=$(awk "/^recycle_day_${engine}_$setting ?:/{sub(/^[^:]+ *: */,\"\");gsub(/^\"|\"$/,\"\");print;exit}" "$secrets_file")
    [[ $tmpval ]] && declare "$engine[$setting]=$(setvar "$tmpval")"
    unset tmpval
  done
done

# How to define extras
for engine in ${supported_engines[@]}; do
  declare -n ref=$engine
  oifs=$IFS
  IFS='|'
  for word in ${ref[extra]}; do
    [[ ! $word =~ ^[A-Za-z0-9_]+=. ]] && echo "Error: $word is not a valid extra setting" && exit 1
    key=${word%%=*}
    value=${word#*=}
    value=${value//%%PIPE%%/|}
    ref[$key]=$value
  done
  IFS=$oifs
done

usage() {
  echo "usage: $(basename $0) [-h] [-D] [-d] [-v] [-j] [-t TESTDATE] [-a ANSWER] [-m MIN_AGREE]"
  echo "                      [ENGINELIST] [MODELLIST]"
  echo "  -d           : Print debug information (second -d is extra debug information)"
  echo "  -d           : Print debug information and exit"
  echo "  -v           : Be verbose (second -v is extra verbose)"
  echo "  -j           : Output using JSON"
  echo "  -J           : Output simple response (i.e. 'Friday')"
  echo "  -t TESTDATE  : Use a test date instead of today (must be YYYY-mm-dd)"
  echo "  -a ANSWER    : Hardcode an answer"
  echo "  -m MIN_AGREE : Minimum number of LLMs must agree on answer (default: $min_agree)"
  echo
  echo "  ENGINELIST can one or more of: ${supported_engines[@]}"
  echo "  If specified, MODELLIST must be: A list of models that would have to match the ENGINE list"
  echo "  The first engine given would be matched with the first model given"
  echo "  ENGINELIST and MODELLIST are space separated on the command line"
  echo "  If MODELLIST is empty and ENGINELIST is set, models will be used from $secrets_file"
  echo "  Examples:"
  echo "    $(basename $0) -j ollama gemma3:4b localai gemma-3-4b-it"
  echo "    $(basename $0) -j ollama localai gemma3:4b gemma-3-4b-it"
  echo "    $(basename $0) -j gemma3:4b gemma-3-4b-it ollama localai"
  exit $1
}

while getopts ":hdDvJjt:a:m:" opt; do
  case $opt in
    d)
       $debug && extra_debug=true
       debug=true ;;
    D)
       debug=true
       debug_exit=true ;;
    v)
       $verbose && extra_verbose=true
       verbose=true
       ;;
    j) output_json=true ;;
    J) output_json=false ;;
    a) answer=$OPTARG ; answers[commandline]=$answer; answers[given]=$answer;;
    t)
       if [[ $OPTARG =~ ^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$ ]]; then
         today_date=$(date -d "$OPTARG" "+%Y-%m-%d")
         [ $? != 0 ] && echo "Error: Could not use date '$OPTARG'" && exit 1
       else
         echo "Error: Invalid date format ($OPTARG)"
         exit 1
       fi
       ;;
    m)
       [[ ! $OPTARG =~ ^[0-9]+$ ]] && echo "Error: MIN_AGREE must be a number" && exit 1
       min_agree=$OPTARG ;;
    *) usage ;;
  esac
done
shift $((OPTIND -1))

engines=()
models=()
engines_list="${supported_engines[@]}"
engines_list="${engines_list// /|}"
while [ -n "$1" ]; do
  if [[ $1 =~ ^($engines_list)$ ]]; then
    engines+=($1)
  else
    models+=($1)
  fi
  shift
done
if [ ${#engines[@]} -gt 0 ]; then
  for engine in ${supported_engines[@]}; do
    declare "${engine}_enabled=false"
  done
  for engine in "${engines[@]}"; do
    declare "${engine}_enabled=true"
  done
  engine_order="${engines[@]}"
fi
if [ ${#engines[@]} -gt 1 ]; then
  if [ ${#models[@]} -eq 1 ]; then
    for engine in "${engines[@]}"; do
      echo "${engine}_model=${models[0]}"
      declare "${engine}_model=${models[0]}"
    done
  elif [ ${#engines[@]} -eq ${#models[@]} ]; then
    for i in $(seq 0 $((${#engines[@]} - 1))); do
      echo "${engines[$i]}_model=${models[$i]}"
      declare "${engines[$i]}_model=${models[$i]}"
    done
  else
    if [ ${#models[@]} -ne 0 ]; then
      echo "Error: Engine/Model mismatch. The same number of engines and models must be passed." > /dev/stderr
      echo > /dev/stderr
      usage 1
    fi
  fi
elif [ ${#engines[@]} -eq 1 ]; then
  min_agree=1
  set -x
  [ ${#models[@]} -gt 0 ] && declare "${engine}_model=${models[@]}"
    set +x
  #if [ ${#models[@]} -eq 1 ]; then
  #  declare "${engine}_model=${models[0]}"
  #else
  #  if [ ${#models[@]} -ne 0 ]; then
  #    echo "Error: Engine/Model mismatch. The same number of engines and models must be passed." > /dev/stderr
  #    echo > /dev/stderr
  #    usage 1
  #  fi
  #fi
fi

# Get whether Home Assistant toggle for using AI is enabled
[[ ! $hass_api_key ]] && echo "Error: Cannot determine hass_api_key from $secrets_file" && exit 1
use_ai=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_boolean.use_ai_for_recycle_day | jq -r .state)
if [ "${use_ai,,}" != "on" ]; then
  $debug && echo "Warning: Use AI for Recycle Day is not 'on' in Home Assistant" > /dev/stderr
  exit
fi

# Get normal recycle day from Home Assistant
normal_recycle_day=$(curl -skSL -H "Authorization: Bearer $hass_api_key" $home_assistant_base_url/api/states/input_select.recycle_day | jq -r .state)
[[ ! $normal_recycle_day ]] && normal_recycle_day=$recycle_default_day
$verbose && echo "Normal recycle day: $normal_recycle_day" > /dev/stderr

# Set reference day to the normal recycle day for this week (or of the passed week)
epoch=$(date ${today_date:+-d $today_date} +%s)
dow=$(date ${today_date:+-d $today_date} +%w)
reference_date=$(date -d "@$(( epoch + (5 - dow) * 86400 ))" +"%A, %B %-d")
reference_ymd=$(date -d "@$(( epoch + (5 - dow) * 86400 ))" +"%Y-%m-%d")
$verbose && echo "Reference date: $reference_date ($reference_ymd)" > /dev/stderr

# Determine the URL for the county's alert text on the recycle URL
xmllint=false
command -v xmllint &> /dev/null && xmllint=true
if $xmllint; then
  county_alert_url=$(curl -sL $recycle_url_main | \
    xmllint --html --xpath 'string(//div[@id="alert"]/following-sibling::script)' - 2>/dev/null | \
    sed -n 's/.*load("\([^"]*\)".*/\1/p')
else
  county_alert_url=$(curl -sL $recycle_url_main | \
    sed -n 's/.*$("#alert").load("\([^"]*\)".*/\1/p')
fi
$verbose && echo "County Alert URL: $county_alert_url" > /dev/stderr

# Determine the content of the county's alert text
if $xmllint && [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL $county_alert_url | xmllint --html --xpath 'string(//body)' - 2> /dev/null | \
    sed -r 's/^\s*//;/^\s*$/d' | paste -sd " ")
elif [[ $county_alert_url =~ ^https?://.*montgomerycountymd.gov ]]; then
  county_alert_text=$(curl -sL "$county_alert_url" | \
    sed -r ':a;N;$!ba;s/\n/ /g;s/(&nbsp;|\r)/ /g;s/<!--.*-->//g;s/ +/ /g;s/<[^>]*>//g;s/^ +//')
else
  echo "Warning: Invalid MoCo Alert/Warning URL ($county_alert_url)" > /dev/stderr
fi
if $extra_verbose; then
  echo "County Notice:"
  echo "    $county_alert_text" | fold -sw $((COLUMNS - 4)) | sed "2,\$s/^/$(printf '%*s' 4)/"
elif $verbose; then
  width=$((COLUMNS - 4))  # Number of columns - width of "County Notice: " - padding
  unset dots
  county_notice="$(echo "County Notice: \"$(echo "$county_alert_text" | paste -sd ' ')" | fold -sw $width | head -n1)"
  [ ${#county_alert_text} -gt $width ] && dots=…
  printf "%s%s\"\n" "$county_notice" "$dots"
fi

# Set the user message to send to the LLM
# user_message=${user_message:-My normal recycling pickup weekday is $normal_recycle_day and today is $reference_date. $county_alert_text If nothing so far has indicated that the recycling will change this week, then the day the county will pick up my recycle should be the normal recycling pickup weekday. Briefly tell me which weekday will the county come to pick up my recycle this week?}

#user_message="${user_message:-County website notice:
#\"${county_alert_text/// }\"
#
#For the date $reference_date, will my recycling pickup day change due to the county website notice? If yes, by how many days will it be delayed?
#
#Return your answer in the following format (do not add any extra text or explanation):
#{
#  \"date\": \"[INSERT_DATE]\",
#  \"is_affected\": [true/false],
#  \"delay_days\": [number of days delayed, or 0 if not affected]
#}}"
user_message="${user_message:-County website notice:
\"${county_alert_text/// }\"

Consider whether a recycling pickup on $reference_date is during the same week as any holiday mentioned in the notice, if it is on or after the holiday during that week, and if my recycling pickup day will change due to the county website notice. If yes, by how many days will it be delayed?

Return your answer in the following format (do not add any extra text or explanation):
{
  \"date\": \"[INSERT_DATE]\",
  \"is_affected\": [true/false],
  \"delay_days\": [number of days delayed, or 0 if not affected]
}}"

if $extra_verbose; then
  echo "LLM User Message:"
  echo "    $user_message" | fold -sw $((COLUMNS - 4)) | sed "2,\$s/^/$(printf '%*s' 4)/"
elif $verbose; then
  width=$((COLUMNS - 4))  # Number of columns - width of "County Notice: " - padding
  unset dots
  usermsg_text="$(echo "LLM User Message: \"$(echo "$user_message" | paste -sd ' ')" | fold -sw $width | head -n1)"
  [ ${#user_message} -gt $width ] && dots=…
  printf "%s%s\"\n" "$usermsg_text" "$dots"
fi

# The grep string used to find a day of the week
day_search='\b([Ss]un|[Mm]on|[Tt]ues|[Ww]ednes|[Tt]hurs|[Ff]ri|[Ss]atur)day\b'

# If debug mode, print variables
if $debug; then
  echo "Settings: " > /dev/stderr
  for var in secrets_file home_assistant_base_url hass_api_key recycle_url_main county_alert_url recycle_default_day normal_recycle_day today_date reference_date reference_ymd min_agree user_message engine_order ; do
    [ $var = user_message ] && printf ' - %s = "%s"\n' "$var" "$(echo "${!var}" | fold -sw $((COLUMNS - ${#var} - 3))|sed "2,\$s/^/$(printf '%*s' $((${#var} - 3)))/")" > /dev/stderr
    ! [ $var = user_message ] && printf ' - %s = "%s"\n' "$var" "${!var}" > /dev/stderr
  done
  list=$engine_order
  $extra_debug && list=${supported_engines[@]}
  for engine in $list; do
    for setting in ${engine_settings[@]}; do
      declare -n ref=$engine
      printf ' - %s = "%s"\n' "$engine[$setting]" "${ref[$setting]}" > /dev/stderr
    done
  done
  $debug_exit && exit
fi

# Function to check if the minimum number of LLMs agree on their answer
check_agreement() {
  [[ $min_agree = 1 ]] && [[ ${#answers[@]} = 1 ]] && echo ${answers[@]} && return 0

  local count
  local max=0
  local answer=""
  declare -A count

  $verbose && echo "Checking agreement with $min_agree agreements needed" > /dev/stderr
  $debug && echo "methods = ${!answers[@]}" > /dev/stderr
  $debug && echo "answers = ${answers[@]}" > /dev/stderr
  for v in "${answers[@]}"; do [[ $v ]] && ((count["$v"]++)); done
  for v in "${!count[@]}"; do (( count[$v] > max )) && max=${count[$v]} && answer=$v; done
  $verbose && echo "Agreements found: $max" > /dev/stderr
  (( $max < $min_agree )) && return 1
  [[ ! $answer ]] && return 1
  echo $answer
}

# Function to run the LLM engine
run_engine() {
  local engine=${1:-localai}
  declare -n ref=$engine

  ! ${ref[enabled]} && { $verbose&&echo "$engine disabled">/dev/stderr;true; } && return
  [[ ! "${ref[url]}" ]] && { $verbose&&echo "$engine url not set">/dev/stderr;true; } && return
  [[ $engine =~ ^(localai|ollama|chatgpt|claude|gemini|openrouter)$ && ! "${ref[model]}" ]] && return
  [[ $engine =~ ^(chatgpt|claude|gemini|mistral|openrouter)$ && ! "${ref[api_key]}" ]] && return
  [[ $engine =~ ^(mistral)$ && ! "${ref[agent_id]}" && ! "${ref[model]}" ]] && return
  [[ $answer ]] && { $verbose&&echo "Answer already set to $answer">/dev/stderr;true; } && return

  [ -n "${ref[model]}" ] && ref[url]="${ref[url]//%%MODEL%%/${ref[model]}}"

  [ -n "${ref[agent_id]}" ] && unset ref[model]
  $verbose && echo "Using $engine LLM${ref[model]:+ with ${ref[model]}}${ref[agent_id]:+ with an engine agent id}" > /dev/stderr

  local api_header_switch api_header add_header_switch add_header message_content
  if [ -n "${ref[api_key]}" ]; then
    api_header_switch="-H "
    local engine_api_key="${ref[api_key]}"
    case "$engine" in
      claude)
        api_header="x-api-key: ${ref[api_key]}"
        add_header_switch="-H "
        add_header="anthropic-version: ${ref[anthropic_version]}"
        ;;
      gemini)
        api_header="x-goog-api-key: ${ref[api_key]}"
        ;;
      *) api_header="Authorization: Bearer ${ref[api_key]}" ;;
    esac
  fi
  case "$engine" in
    chatgpt)
      message_content='{
        "input": $user_message
      }'
      ;;
    claude|github|openrouter)
      message_content='{
        "messages": [
          {
            "role": "user",
            "content": $user_message
          }
        ]
      }'
      ;;
    gemini)
      message_content='{
        "contents": [
          {
            "parts": [
              {
                "text": $user_message
              }
            ]
          }
        ]
      }'
      # Determine if model supports thinking (and is gemini-3)
      if [[ ${ref[model]} =~ ^gemini-[3-9] ]]; then
        t="${ref[url]%:*Content}"
        thinking=$(curl -s "$t?key=${ref[api_key]}" | jq -r '.thinking')
        [ "$thinking" != true ] && thinking=false

        $thinking && [ -n "${ref[thinking_level]}" ] && \
        message_content=$({
            jq -n --arg user_message "$user_message" "$message_content"
            jq -n '{
            "generationConfig": {
              "thinkingConfig": {
                "thinkingLevel": "'${ref[thinking_level]:-low}'"
              }
            }
          }'
          } | jq -s add)
      fi
      ;;
    localai)
      message_content='{
        "messages": [
          {
            "role": "user",
            "reasoning": "'${ref[reasoning_level]:-low}'",
            "content": $user_message
          }
        ]
      }'
      ;;
    mistral)
      message_content='{
        "inputs": [
          {
            "role": "user",
            "content": $user_message
          }
        ]
      }'
      if [ -n "${ref[agent_id]}" ]; then
        message_content=$({
          jq -n --arg user_message "$user_message" "$message_content"
          jq -n '{"agent_id": "'${ref[agent_id]}'"}'
        } | jq -s add)
      fi
      ;;
    ollama)
      message_content='{
        "stream": false,
        "prompt": $user_message
      }'
      ;;
  esac
  [ -z "$message_content" ] && echo "Error: Could not generate message_content for LLM" && exit 1
  message_content=$(jq -n --arg user_message "$user_message" "$message_content")

  local data=$(jq -n \
    --arg max_tokens "${ref[max_tokens]}" \
    --arg prompt "${ref[prompt]}" \
    --arg model "${ref[model]}" \
    'if $model != "" then . + {model: $model} else . end
    | if $max_tokens != "" then . + {max_tokens: ($max_tokens|tonumber)} else . end
    | if $prompt != "" then . + {prompt: $prompt} else . end
    ')
  [[ "$data" == "null" ]] && data="{}"
  data=$(jq -s '.[0] * .[1]' <(echo $data) <(echo "$message_content"))
  $debug && { echo "JSON data for curl:" && echo "$data" | sed 's/^/  /'; } > /dev/stderr
  $debug && set -x
  local tmpanswer=$(curl -s "${ref[url]}" \
    $api_header_switch${api_header:+"$api_header"} $add_header_switch${add_header:+"$add_header"} \
    -H "Content-Type: application/json" -d "$data")
  $debug && set +x
  $debug && echo "$engine output: $tmpanswer" > /dev/stderr
  tmpanswer=$(echo "$tmpanswer" | jq -r "${ref[match]}")
  $debug && echo "$engine post-jq-engine-match output: $tmpanswer" > /dev/stderr
  tmpanswer="${tmpanswer#*</think>}"
  tmpanswer=$(echo "$tmpanswer" | sed '/^```/d' | jq -Mr '"is_affected=\(.is_affected) delay_days=\(.delay_days)"')
  ret=$?
  $debug && echo "$engine post-jq output: $tmpanswer" > /dev/stderr
  local is_affected delay_days
  if [ $ret != 0 ]; then
    tmpanswer="Bad json output"
  else
    if [[ $tmpanswer =~ ^is_affected=(true|false)" "delay_days=[0-6]$ ]]; then
      eval "$tmpanswer"
      tmpanswer=$(date -d @$(( $(date -d $reference_ymd +%s) + $delay_days * 86400 )) +%A)
    else
      tmpanswer="Invalid json format: $tmpanswer"
    fi
  fi
  unset ref

  if [[ $tmpanswer ]]; then
    $verbose && echo "$engine answer: '$tmpanswer'" > /dev/stderr
    answers[$engine]=$tmpanswer
    answer=$(check_agreement)
    [ $? != 0 ] && $debug && echo "No agreement after ${!answers[@]}" > /dev/stderr
  fi
}

# Execute functions for LLMS
$verbose && echo "Running engines in this order: $engine_order" > /dev/stderr

for engine in $engine_order; do
  run_engine $engine
done

if [[ $answer ]]; then
  if $output_json; then
    $verbose && echo "Answers contains: $(declare -p answers | sed -r 's/declare -[a-z]+ answers=//i;s/(\(|\) ?)//g')"
    json=$(for k in "${!answers[@]}"; do
      jq -n --arg k "$k" --arg v "${answers[$k]}" '{($k): $v}'
    done | jq -s add)
    [[ ! $json ]] && echo "Error: Cannot build json from answers" && exit
    jq -M -n --arg a "$answer" --argjson as "$json" '{"answers": $as, "answer": $a}'
  else
    echo $answer
  fi
elif [ ${#answers[@]} = 0 ]; then
  echo "Error: No LLMs were used to determine date (none configured?)"
else
  echo "Error: Could not determine answer"
  exit 1
fi

